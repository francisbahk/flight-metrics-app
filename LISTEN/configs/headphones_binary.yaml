tag: headphones_binary

data_csv: input/final_headphones_index_binary.csv

metric_columns:
  - product_name
  - brand
  - price
  - type
  - connectivity
  - noise_cancellation
  - battery_life
  - bluetooth_version
  - driver_size
  - weight
  - water_resistance
  - microphone
  - review_rating
  - review_count
  - description
  - meets_requirements

metric_signs:
  product_name: 0        
  brand: 0               
  price: -1              
  type: 0                
  connectivity: 0        
  noise_cancellation: 0  
  battery_life: 1        
  bluetooth_version: 1   
  driver_size: 1         
  weight: -1             
  water_resistance: 0    
  microphone: 0          
  review_rating: 1       
  review_count: 1        
  description: 0     
  meets_requirements: 1

non_numeric_metrics:
  - product_name
  - brand
  - description

prompts:
  scenario_header: |
    You are an audio equipment reviewer choosing the best headphones. 
    Use these definitions:
    - product_name: name of the product (non-metric, weight always 0).
    - brand: manufacturer reputaton (non-metric, weight always 0).
    - price: cost measured in dollars.
    - type: headphone design.
    - connectivity: wired vs wireless.
    - noise_cancellation: active vs passive.
    - battery_life: measured in hours.
    - bluetooth_version: higher versions are newer.
    - driver_size: measured in millimeters.
    - weight: measured in ounces.
    - water_resistance: measured subjectively and also through the ipXX rating system, which measures a device's protection against solids (first digit) and liquids (second digit), with higher numbers indicating stronger resistance.
    - microphone: presence/quality of mic 
    - review_rating: average customer rating 
    - review_count: number of reviews
    - description: qualitative marketing text (non-metric, weight always 0)
    - meets_requirements: binary value denoting if the primary requirements are being met (1 is met, 0 is not met).
    
    Also, the data in the data_csv is numerical except in the columns product_name, brand, and description). However, for some of the columns in which there is 
    numerical data, there was originally non-numerical data. We dealt with this by creating a mapping from numbers to data.
    For example, in brand, we mapped all unique brands to numbers which show up in the table. 
    Our mapping is below:
        TYPE MAPPING:
      ==================================================
      1: Gaming
      2: In-Ear
      3: Neckband
      4: On-Ear
      5: Open-Ear
      6: Over-Ear
      7: Sport
      8: True Wireless
      BRAND MAPPING:
      ==================================================
      1: AMORNO
      2: Apple
      3: Audio-Technica
      4: BERIBES
      5: BHNYBWUL
      6: Beats
      7: Beyerdynamic
      8: Bose
      9: Bowers & Wilkins
      10: EAORUL
      11: EarFun
      12: INFURTURE
      13: JBL
      14: JLab
      15: KVIDIO
      16: LORELEI
      17: Marshall
      18: OneOdio
      19: PHILIPS
      20: Picun
      21: RUNOLIM
      22: SHOKZ
      23: Sennheiser
      24: Sony
      25: Soundcore
      26: TOZO
      27: YY KATTY
      28: ZIHNIC
      29: beyerdynamic
      30: iClever
      31: kurdene
      32: noot products
      CONNECTIVITY MAPPING:
      ==================================================
      1: Wired
      2: Wireless
      NOISE_CANCELLATION MAPPING:
      ==================================================
      1: Active
      2: Passive
      WATER_RESISTANCE MAPPING:
      ==================================================
      1: ip54
      2: ip55
      3: ipx5
      4: ipx7
      5: not water resistant
      6: water & dust resistant
      7: water resistant
      8: water-resistant
      9: waterproof
      MICROPHONE MAPPING:
      ==================================================
      1: No
      2: Yes
    These mappings are not ordered. For example, for water_resistance mapping, water-resistant is not strictly better than ip54. 
    It is up to you to use these mappings to convert random categorial numerical data (for columns where mappings exist) 
    into useful non-numerical qualitative information about each product. There should be no comparisons between options if you have not converted numbers
    from columns where mappings exist into qualitative data, because otherwise the comparisons would essentially be between random numbers.

  comparison_base: |
    {scenario_header}
    Your task: Identify the SINGLE BEST pair of headphones from the options below.

  utility_base: |
    {scenario_header}
    Your task: Define a utility function by assigning weights to these metrics, reflecting priorities for audio quality, comfort, durability, and value.
    IMPORTANT:
    - product_name and description are non-metrics; their weights must always be 0.
    - Some metrics are monotonic (e.g., lower price, higher rating).
    - Some metrics may have optimal mid-ranges (e.g., weight).
    - Some are categorical and subjective (e.g., connectivity, type).
    - Each metric is first mapped to a normalized [0,1] preference score. The final utility is:

      utility = sum(weight_i * score_i) for all metrics

    Return your response in this EXACT JSON format (include ALL listed metric keys):
    {
      "weights": {
        "product_name": 0.0,
        "brand": 0.0,
        "price": 0.0,
        "type": 0.0,
        "connectivity": 0.0,
        "noise_cancellation": 0.0,
        "battery_life": 0.0,
        "bluetooth_version": 0.0,
        "driver_size": 0.0,
        "weight": 0.0,
        "water_resistance": 0.0,
        "microphone": 0.0,
        "review_rating": 0.0,
        "review_count": 0.0,
        "description": 0.0
        "meets_requirements" : 0.0
      },
      "formula": "utility = sum(weight_i * score_i) for all metrics (score_i ∈ [0,1])",
      "description": "Brief explanation of your weighting rationale"
    }

    STRICT OUTPUT RULES:
    - Output ONLY a valid JSON object. No code fences. No prose. No Python.
    - product_name and description weights must remain 0.0 always.
    - For all other metrics, weights may be positive or negative. Use positive weights where higher is better and negative weights where lower is better
    - Do not include any additional keys beyond weights, formula, description.
    - End your output with the delimiter: <END_JSON>

  utility_refinement: |
    You are refining a utility function for headphone evaluation (iteration {iteration}).

    CURRENT UTILITY FUNCTION (that produced the best choice below):
    Weights: {weights}
    Formula: {formula}
    Description: {description}

    BEST HEADPHONE FOUND with the above utility function:
    {best_solution}

    ANALYSIS:
    - Does this choice seem reasonable given the stated preferences?
    - Are any metrics over- or under-weighted?
    - Should any penalties or bonuses be adjusted?
    - product_name and description weights must remain 0.

    Your task: Based on this best choice, adjust the utility function weights if needed. Consider: {policy_guidance}

    Return your response in this EXACT JSON format (include ALL listed metric keys):
    {{
      "weights": {{
        "product_name": 0.0,
        "brand": 0.0,
        "price": <adjusted_weight>,
        "type": <adjusted_weight>,
        "connectivity": <adjusted_weight>,
        "noise_cancellation": <adjusted_weight>,
        "battery_life": <adjusted_weight>,
        "bluetooth_version": <adjusted_weight>,
        "driver_size": <adjusted_weight>,
        "weight": <adjusted_weight>,
        "water_resistance": <adjusted_weight>,
        "microphone": <adjusted_weight>,
        "review_rating": <adjusted_weight>,
        "review_count": <adjusted_weight>,
        "description": 0.0,
        "meets_requirements": <adjusted_weight>
      }},
      "formula": "utility = sum(weight_i * score_i) for all metrics (score_i ∈ [0,1])",
      "description": "Brief explanation of your adjustments and reasoning based on the best choice shown above"
    }}

    STRICT OUTPUT RULES:
    - Output ONLY a valid JSON object. No code fences. No prose. No Python.
    - product_name and description weights must remain 0.0 always.
    - For all other metrics, weights may be positive or negative. Use positive weights where higher is better and negative weights where lower is better
    - Do not include any additional keys beyond weights, formula, description.
    - If no change is needed, return the previous weights unchanged in the JSON.
    - End your output with the delimiter: <END_JSON>

# Modes for headphone scenario
default_mode: STUDENT

modes:
  BASE:
    prompt: >

  STUDENT_HARD:
    prompt: >
      Objective:
          I am seeking recommendations for premium wireless over-ear headphones designed for both long study sessions and high-quality music listening. The ideal options should balance advanced features, comfort, and practicality to support a student lifestyle.
      
      Primary Requirements (Must-Haves):
        HARD CONSTRAINTS:
          - type MUST BE 6 (Over-Ear)
          - connectivity MUST BE 2 (Wireless)
          - noise_cancellation MUST BE 1 (Active)
          - microphone MUST BE 2 (Yes)
          - battery_life MUST BE >= 30 hours
        Type: Wireless, over-ear headphones (not earbuds).
        Core Features: Active Noise Cancellation (ANC) and a built-in microphone.
        Battery Life: Minimum 30 hours of playback per charge to ensure multi-day use without nightly recharging.
        Comfort & Weight: A balanced design—substantial enough to feel durable and premium, yet light enough for several hours of wear without causing head or neck strain.
        Brand: At least one recommendation must feature a Sennheiser model.
        User Reviews: Preference for models with both a high average rating and a large number of reviews, signaling broad user satisfaction.
    
      Secondary Criteria (Nice to Have):
        Product Information: Descriptions should highlight either superior sound quality or exceptional long-wear comfort.
        Price: When two or more options meet all requirements equally, the more affordable option is preferred.
        Battery Life: Minimum 30 hours of playback per charge to ensure multi-day use without nightly recharging. 
    human_sol: [4,22,1,2,74,42,15,46, 21, 18,0,5,3,20,14]
